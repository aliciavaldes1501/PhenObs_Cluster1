---
title: "PhenObs analyses"
author: "Alicia Valdés"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  pdf_document:
    toc: yes
    toc_depth: 4
  html_document:
    toc: yes
    toc_depth: '4'
    df_print: paged
  word_document:
    toc: yes
    toc_depth: '4'
editor_options:
  chunk_output_type: inline
---

# Load libraries

```{r}
library(readr)
library(here)
library(rWCVP)
library(tidyverse)
library(purrr)
library(sf)
library(glmmTMB)
library(ggeffects)
library(rgbif)
library(readxl)
library(gridExtra)
library(furrr)
```

# Occurrence matrices

## Package rWCVP

This package allows to access data from the World Checklist of Vascular Plants.

Read species list from PhenObs:

```{r}
species <- read_csv(here("data", "raw", "list_species_PhenObs.csv"))
species
```

```{r}
# taxonomy data
names <- rWCVPdata::wcvp_names

# distribution data
distributions <- rWCVPdata::wcvp_distributions
```

Filter the WCVP:

```{r}
# Filtering the WCVP to generate lists or summaries of vascular plant species 
# in particular areas. 
# Two arguments:
# taxon: the name of a valid taxon with a taxonomic rank of species or higher 
# (e.g. the species “Myrcia almasensis”, the genus “Myrcia”, or the family “Myrtaceae”).
# area: a vector of WGSRPD level 3 codes for the regions you want to focus on.
# These arguments can be combined in the wcvp_checklist, wcvp_occ_mat, 
# and wcvp_summary to generate outputs for focal taxa in a desired area. 

matches <- wcvp_match_names(species, name_col = "species", fuzzy = TRUE,
                            progress_bar = FALSE)

# Generate occurency matrix

# Extract the genus
genera <- species %>%
  mutate(genus = word(species, 1)) %>%
  distinct(genus) %>%
  pull(genus)
```

We want to get an occurrence matrix for all countries in Europe that are included in our RL data!

Read the RL data:

Read data:

```{r}
redlist <- read_tsv(here("data", "raw", "redlist_MOTIVATE_subset.csv"))
redlist
redlist %>% distinct(Country) %>% arrange(Country) %>% print(n = 50)
```

```{r}
area_codes = c(
  get_wgsrpd3_codes("Albania"),
  get_wgsrpd3_codes("Austria"), # Includes Austria and:
  # L4	AUT-LI	Liechtenstein
  get_wgsrpd3_codes("Baltic States"), # Includes:
  # L4	BLT-ES	Estonia
  # L4	BLT-LA	Latvia
  # L4	BLT-LI	Lithuania
  get_wgsrpd3_codes("Belarus"),
  get_wgsrpd3_codes("Belgium"), # Includes Belgium and:
  # L4	BGM-LU	Luxembourg
  get_wgsrpd3_codes("Bulgaria"),
  get_wgsrpd3_codes("Cyprus"),
  get_wgsrpd3_codes("Czechoslovakia"), # Includes:
  # L4	CZE-CZ	Czech Republic
  # L4	CZE-SL	Slovakia
  get_wgsrpd3_codes("Denmark"),
  get_wgsrpd3_codes("Finland"),
  get_wgsrpd3_codes("France"),
  get_wgsrpd3_codes("Germany"),
  get_wgsrpd3_codes("Greece"),
  get_wgsrpd3_codes("Hungary"),
  get_wgsrpd3_codes("Ireland"),
  get_wgsrpd3_codes("Italy"), # Includes Italy and:
  # L4	SIC-MA	Malta
  #   > get_wgsrpd3_codes("Sicilia")
  # ℹ Matches to input geography found at Area (Level 3)
  # [1] "SIC"
  # > get_wgsrpd3_codes("Italy")
  # ℹ Matches to input geography found at Area (Level 3) and Country (Gallagher)
  # [1] "ITA" "SAR" "SIC"
  get_wgsrpd3_codes("Netherlands"),
  get_wgsrpd3_codes("Norway"),
  get_wgsrpd3_codes("Poland"),
  get_wgsrpd3_codes("Portugal"),
  get_wgsrpd3_codes("Romania"),
  get_wgsrpd3_codes("Russia"),
  get_wgsrpd3_codes("Spain"), # Includes Spain and:
  # L4	SPA-AN  Andorra
  get_wgsrpd3_codes("Sweden"),
  get_wgsrpd3_codes("Switzerland"),
  get_wgsrpd3_codes("Turkey"),
  get_wgsrpd3_codes("Ukraine"), # Includes Ukraine and:
  # L4	UKR-MO	Moldova
  get_wgsrpd3_codes("Great Britain"), # Includes United Kingdom
  get_wgsrpd3_codes("Yugoslavia") # Includes:
  # L4	YUG-BH	Bosnia- Herzegovina
  # L4	YUG-CR	Croatia
  # L4	YUG-KO	Kosovo
  # L4	YUG-MN	Montenegro
  # L4	YUG-SE  Serbia
  # L4	YUG-SL	Slovenia
  )
```

```{r}
# Define safe wrapper for wcvp_occ_mat
# Apply wcvp_occ_mat to each genus
safe_occ_mat <- possibly(
  function(genus) {
    wcvp_occ_mat(
      taxon = genus,
      taxon_rank = "genus",
      area_codes = area_codes
    ) %>%
      mutate(input_genus = genus)
  },
  otherwise = NULL
)
```

```{r message=FALSE, warning=FALSE}
# Apply to all genera
occurrence_matrix_genera <- map_df(genera, safe_occ_mat)
occurrence_matrix_genera
```

```{r}
# Filter for species that are on the PhenObs list
occurrence_matrix_species <- occurrence_matrix_genera %>%
  filter(taxon_name %in% species$species)
nrow(occurrence_matrix_species) # 161 species of 177 in PhenObs list
```

Species from PhenObs list that were not matched:

```{r}
species %>% filter(!species %in% occurrence_matrix_species$taxon_name)
```

Species not appearing in any of the area_codes from PhenObs:

```{r}
wcvp_distribution(taxon ="Arnica longifolia", taxon_rank = "species") %>%
  wcvp_distribution_map() + ggtitle("Arnica longifolia")
wcvp_distribution(taxon ="Bergenia purpurascens", taxon_rank = "species") %>%
  wcvp_distribution_map() + ggtitle("Bergenia purpurascens")
wcvp_distribution(taxon ="Camassia cusickii", taxon_rank = "species") %>%
  wcvp_distribution_map() + ggtitle("Camassia cusickii")
wcvp_distribution(taxon ="Gunnera manicata", taxon_rank = "species") %>%
  wcvp_distribution_map() + ggtitle("Gunnera manicata")
wcvp_distribution(taxon ="Abelmoschus moschatus", taxon_rank = "species") %>%
  wcvp_distribution_map() + ggtitle("Abelmoschus moschatus")
wcvp_distribution(taxon ="Paeonia delavayi", taxon_rank = "species") %>%
  wcvp_distribution_map() + ggtitle("Paeonia delavayi")
wcvp_distribution(taxon = "Silphium integrifolium", taxon_rank = "species") %>%
  wcvp_distribution_map() + ggtitle("Silphium integrifolium")
wcvp_distribution(taxon = "Trillium sessile", taxon_rank = "species") %>%
  wcvp_distribution_map() + ggtitle("Trillium sessile")
```

Add synonyms:

```{r}
species <- species %>%
  mutate(synonym = case_when(
    species == "Anemone hepatica" ~ "Hepatica nobilis",
    species == "Anemone hupehensis" ~ "Eriocapitella hupehensis",
    species == "Atropa belladonna" ~ "Atropa bella-donna",
    species == "Centranthus ruber" ~ "Valeriana rubra",
    species == "Ficaria verna" ~ "Ranunculus ficaria",
    species == "Hibiscus moschatus" ~ "Abelmoschus moschatus",
    species == "Primula acaulis" ~ "Primula vulgaris",
    species == "Securigera varia" ~ "Coronilla varia",
    species == "Stachys officinalis" ~ "Betonica officinalis",
    TRUE ~ NA_character_
  ))
```

Redo generation of occurrence matrix:

```{r}
genera <- species %>%
  mutate(genus = ifelse(
    !is.na(synonym), word(synonym, 1),
    word(species, 1)
    )
    ) %>%
  distinct(genus) %>%
  pull(genus)
```

```{r message=FALSE, warning=FALSE}
# Apply to all genera
occurrence_matrix_genera <- map_df(genera, safe_occ_mat)
occurrence_matrix_genera
```

```{r}
# Filter for species that are on the PhenObs list
species <- species %>%
  mutate(species_corrected = ifelse(
    !is.na(synonym), synonym,
    species
  ))
occurrence_matrix_species <- occurrence_matrix_genera %>%
  filter(taxon_name %in% species$species_corrected)
nrow(occurrence_matrix_species) # 169 species of 177 in PhenObs list
```

Species from PhenObs list that were not matched

```{r}
# According to WCVP, these species are not appearing in any European country
species_absent <- species %>% 
  filter(!species_corrected %in% occurrence_matrix_species$taxon_name)
species_absent
species_present <-species %>%
  filter(species_corrected %in% occurrence_matrix_species$taxon_name)
species_present
```

Occurrence matrix for countries:

```{r}
occurrence_matrix_species_countries <- occurrence_matrix_species %>%
  select(-input_genus) %>%
  pivot_longer(cols = 3:59, names_to = "LEVEL3_COD") %>% 
  left_join(wgsrpd_mapping %>% select(LEVEL3_COD, COUNTRY) %>%
              # Remove one duplicate row
              distinct()) %>%
  group_by(taxon_name, COUNTRY) %>%
  summarise(occurrence = max(value), .groups = "drop")
```

## TO DO: GIFT R package

Allows to access data from the Global Inventory of Floras and Traits

## TO DO: rgbif package

Allows retrieving data from GBIF.

# MOTIVATE Red List data

Do not only use the RL of the countries where we have our botanical gardens, instead use the RL from all available countries in Europe!

## Matching Phenobs - RL

Try to match the full PhenObs spp list with the RL to see how many species are there in each category for each country.

Christoph: For matching of spp, standardize both sp_list and RL to the names currently used in GBIF before matching. In script for phylogenetic tree, but so far I cannot find it.

## Full PhenObs species list

Read the full PhenObs species list from 2022 data:

```{r}
sp_list <- read_excel("data/raw/full_list_sp_phenobs_2022.xlsx") %>%
  rename(species = Species) 
```

### Define functions

```{r}
clean_name <- function(x) {
  x %>% str_squish() %>% str_trim()
}

# Helper: extrae un campo con comprobación de existencia y aplica un "cast" opcional
get_field <- function(res, field, default = NA_character_, cast = identity) {
  if (!is.null(res) && field %in% colnames(res) && length(res[[field]]) > 0) {
    # cogemos el primer valor (name_backbone devuelve una fila "mejor")
    return(cast(res[[field]][1]))
  } else {
    return(cast(default))
  }
}

resolve_gbif <- function(name) {
  nm_raw <- name
  nm <- clean_name(name %||% "")
  
  # Especie vacía/NA -> fila con esquema completo
  if (is.na(nm_raw) || nm == "") {
    return(tibble(
      query_name = ifelse(is.na(nm_raw), NA_character_, nm),
      matched_name = NA_character_,
      matched_rank = NA_character_,
      match_type = NA_character_,
      match_status = NA_character_,
      usageKey = NA_integer_,
      acceptedUsageKey = NA_integer_,
      acceptedScientificName = NA_character_,
      kingdom = NA_character_,
      phylum = NA_character_,
      class = NA_character_,
      order = NA_character_,
      family = NA_character_,
      genus = NA_character_
    ))
  }

  # Intento con rank species, luego sin rank
  res1 <- tryCatch(rgbif::name_backbone(name = nm, rank = "species"), error = function(e) NULL)
  res <- if (!is.null(res1) && nrow(res1) > 0) res1 else {
    tryCatch(rgbif::name_backbone(name = nm), error = function(e) NULL)
  }

  # Si no hay filas, devolvemos NA con esquema completo
  if (is.null(res) || nrow(res) == 0) {
    return(tibble(
      query_name = nm,
      matched_name = NA_character_,
      matched_rank = NA_character_,
      match_type = NA_character_,
      match_status = NA_character_,
      usageKey = NA_integer_,
      acceptedUsageKey = NA_integer_,
      acceptedScientificName = NA_character_,
      kingdom = NA_character_,
      phylum = NA_character_,
      class = NA_character_,
      order = NA_character_,
      family = NA_character_,
      genus = NA_character_
    ))
  }

  # Extraemos con comprobación de nombres y forzamos tipos
  sci <- get_field(res, "scientificName", default = NA_character_, cast = as.character)
  acc_sci <- get_field(res, "acceptedScientificName", default = sci, cast = as.character)
  tibble(
    query_name = nm,
    matched_name = sci,
    matched_rank = get_field(res, "rank", default = NA_character_, cast = as.character),
    match_type = get_field(res, "matchType", default = NA_character_, cast = as.character),
    match_status = get_field(res, "status", default = NA_character_, cast = as.character),
    usageKey = get_field(res, "usageKey", default = NA_integer_, cast = function(x) as.integer(x)),
    acceptedUsageKey = get_field(res, "acceptedUsageKey", default = NA_integer_, cast = function(x) as.integer(x)),
    acceptedScientificName = acc_sci,
    kingdom = get_field(res, "kingdom", default = NA_character_, cast = as.character),
    phylum  = get_field(res, "phylum",  default = NA_character_, cast = as.character),
    class   = get_field(res, "class",   default = NA_character_, cast = as.character),
    order   = get_field(res, "order",   default = NA_character_, cast = as.character),
    family  = get_field(res, "family",  default = NA_character_, cast = as.character),
    genus   = get_field(res, "genus",   default = NA_character_, cast = as.character)
  )
}

# Vectorizado; usa bind_rows (une nombres) y opcionalmente throttle
resolve_vec <- function(v, sleep = 0) {
  v %>%
    map(function(x) {
      out <- resolve_gbif(x)
      if (sleep > 0) Sys.sleep(sleep)
      out
       }) %>%
    bind_rows()
}

resolve_vec_parallel <- function(v, workers = 6, throttle = 0.02) {
  plan(multisession, workers = workers)
  on.exit(plan(sequential), add = TRUE)

  future_map(
    v,
    function(x) {
      out <- resolve_gbif(x)
      if (throttle > 0) Sys.sleep(throttle)
      out
    },
    .progress = TRUE,
       .options = furrr::furrr_options(seed = TRUE)  # <- clave
  ) %>% dplyr::bind_rows()
}
```

### Resolve

Resolve sp_list$species to GBIF accepted names:

```{r}
sp_list_matched <- resolve_vec(sp_list$species) %>%
  mutate(source = "sp_list") %>%
  # Keep original species for reference
  bind_cols(sp_list %>% rename(original_species = species))
# Inspect resolution quality
sp_list_matched %>%
   count(match_type, match_status, matched_rank)
```

Resolve redlist$`sPlot concept unified` to GBIF accepted names

```{r}
plan(multisession, workers = 10) # adjust workers to your CPU

unique_names <- redlist %>%
  filter(lifeform_description != "tree") %>% # Remove trees
  distinct(`sPlot concept unified`) %>%
  filter(str_detect(`sPlot concept unified`, "\\s")) # keep names with space (likely species)
  
redlist_matched <- resolve_vec_parallel(unique_names$`sPlot concept unified`) %>%
  mutate(source = "redlist") 

plan(sequential)
```

```{r}
# Inspect resolution quality
redlist_matched %>%
  # Remove duplicate rows
  distinct() %>%
  count(match_type, match_status, matched_rank)
redlist_matched_final <- redlist %>% 
  # Remove columns that have equal names
  select(-match_type, -match_status, -family, -genus) %>%
  # Keep original species for reference
  rename(original_species = `sPlot concept unified`) %>%
  left_join(redlist_matched %>% # Remove duplicate rows
              distinct(), 
            by = join_by(original_species == query_name))
```

Join:

```{r}
redlist_phenobs_all <- sp_list_matched %>%
  select(query_name, matched_name, usageKey, acceptedUsageKey, 
         acceptedScientificName, source, original_species) %>%
  # Build canonical GBIF key
  mutate(gbif_key = coalesce(acceptedUsageKey, usageKey)) %>%
  select(-usageKey, -acceptedUsageKey, -matched_name, -acceptedScientificName,
         -source, -original_species) %>%
  left_join(
    redlist_matched_final %>%
      # Build canonical GBIF key
      mutate(gbif_key = coalesce(acceptedUsageKey, usageKey)) %>%
      select(-usageKey, -acceptedUsageKey),
    by = "gbif_key")
```

```{r}
redlist_phenobs_all <- redlist_phenobs_all %>%
  # Use acceptedScientificName from GBIF as species name 
  mutate(species = acceptedScientificName) %>%
  # Clean whitespace and keep only "Genus species"
  mutate(species = str_squish(species),
         species = case_when(
           is.na(species) ~ NA_character_,
           species == "Iris × germanica L." ~ "Iris × germanica", # Special case
           .default = word(species, 1, 2) # first two words
           )) %>%
  # Keep columns that I think I will use
  select(species, Redlist_cat, Threat, Country, Publ_year,
         redlist_source, Continent)
redlist_phenobs_all
```


## Sensitivity PhenObs species list

Resolve species_present$species_corrected to GBIF accepted names:

```{r}
species_present_matched <- resolve_vec(species_present$species_corrected) %>%
  # Keep original species for reference
  bind_cols(species_present %>% rename(original_species = species_corrected))
# Inspect resolution quality
species_present_matched %>%
   count(match_type, match_status, matched_rank)
```

Join:

```{r}
redlist_phenobs <- species_present_matched %>%
  select(query_name, matched_name, usageKey, acceptedUsageKey, 
         acceptedScientificName, original_species) %>%
  # Build canonical GBIF key
  mutate(gbif_key = coalesce(acceptedUsageKey, usageKey)) %>%
  select(-usageKey, -acceptedUsageKey, -matched_name, -acceptedScientificName,
         -original_species) %>%
  left_join(
    redlist_matched_final %>%
      # Build canonical GBIF key
      mutate(gbif_key = coalesce(acceptedUsageKey, usageKey)) %>%
      select(-usageKey, -acceptedUsageKey),
    by = "gbif_key")
```

```{r}
redlist_phenobs <- redlist_phenobs %>%
  # Use acceptedScientificName from GBIF as species name
  mutate(species = acceptedScientificName) %>%
  # Clean whitespace and keep only "Genus species"
  mutate(species = str_squish(species),
         species = case_when(
           is.na(species) ~ NA_character_,
           species == "Iris × germanica L." ~ "Iris × germanica", # Special case
           .default = word(species, 1, 2) # first two words
           )) %>%
  # Keep columns that I think I will use
  select(species, Redlist_cat, Threat, Country, Publ_year,
         redlist_source, Continent)
redlist_phenobs
```

# Match country names

Make the country names in RL match with the country names in occurrence_matrix_species_countries:

```{r}
redlist_phenobs_all <- redlist_phenobs_all %>%
  mutate(Country_WGSRPD = case_when(
    Country == "Liechtenstein" ~ "Austria",
    Country %in% c("Estonia", "Latvia", "Lithuania")~ "Baltic States",
    Country == "Luxembourg" ~ "Belgium",
    Country %in% c("Czech Republic", "Slovakia") ~ "Czechoslovakia",
    Country == "Malta" ~ "Italy",
    Country == "Andorra" ~ "Spain",
    Country == "Moldova" ~ "Ukraine",
    Country == "United Kingdom" ~ "Great Britain",
    Country %in% c("Bosnia and Herzegovina", "Croatia", "Kosovo", "Montenegro",
                   "Serbia", "Slovenia") ~ "Yugoslavia",
    TRUE ~ Country))
```

```{r}
redlist_phenobs <- redlist_phenobs %>%
  mutate(Country_WGSRPD = case_when(
    Country == "Liechtenstein" ~ "Austria",
    Country %in% c("Estonia", "Latvia", "Lithuania")~ "Baltic States",
    Country == "Luxembourg" ~ "Belgium",
    Country %in% c("Czech Republic", "Slovakia") ~ "Czechoslovakia",
    Country == "Malta" ~ "Italy",
    Country == "Andorra" ~ "Spain",
    Country == "Moldova" ~ "Ukraine",
    Country == "United Kingdom" ~ "Great Britain",
    Country %in% c("Bosnia and Herzegovina", "Croatia", "Kosovo", "Montenegro",
                   "Serbia", "Slovenia") ~ "Yugoslavia",
    TRUE ~ Country))
```

```{r}
occurrence_matrix_species_countries %>% distinct(COUNTRY) %>% 
  arrange(COUNTRY) %>% print(n = 50)
redlist_phenobs %>% distinct(Country_WGSRPD) %>% arrange(Country_WGSRPD) %>% 
  print(n = 50)
# Turkey is in occurrence matrix, but not in RL,
# otherwise countries match
```

Cases where there is info for more than one year for a species and country:

```{r}
redlist_phenobs_dupl_diff <- redlist_phenobs %>%
  group_by(species, Country_WGSRPD) %>%
  filter(n() > 1, n_distinct(Threat) > 1) %>%
  ungroup()
redlist_phenobs_dupl_diff
```

Keep threat info for the latest publication year. In Russia, there is no info about publ year.

Keep Russia separated:

```{r}
redlist_phenobs_Russia <- redlist_phenobs %>%
  filter(Country_WGSRPD == "Russia")
```

Remove Russia:

```{r}
redlist_phenobs_noRussia <- redlist_phenobs %>%
  filter(Country_WGSRPD != "Russia")
```

For other countries apart from Russia: If there are several rows for same publ year, pick the most severe red list category.

```{r}
severity_order <- c("CR", "EN", "VU", "NT", "LC")

redlist_phenobs_noRussia_latest <- redlist_phenobs_noRussia %>%
  group_by(species, Country_WGSRPD) %>%
  filter(if (all(is.na(Publ_year))) TRUE else 
    Publ_year == max(Publ_year, na.rm = TRUE)) %>%
  slice(which.min(match(Redlist_cat, severity_order))) %>%
  ungroup()

redlist_phenobs_noRussia_latest
```

Check that there is only one entry for each species and country:

```{r}
redlist_phenobs_noRussia_latest %>% 
  group_by(species, Country_WGSRPD) %>%
  count() %>% filter(n > 1)
```

For Russia:

```{r}
severity_threatened <- c("CR", "EN", "VU")
severity_not_threatened <- c("NT", "LC")

redlist_phenobs_Russia <- redlist_phenobs_Russia %>%
  group_by(species) %>%
  # Apply custom logic to pick ONE row but keep all columns
  slice({
    threatened_count <- sum(Threat == "threatened")
    not_threatened_count <- sum(Threat == "not_threatened")
    
    # If there are more threatened rows than not threatened
    if (threatened_count > not_threatened_count) {
      # pick the first threatened row
      which.max(Threat == "threatened") 
      # Else if there are more not threatened rows
    } else if (not_threatened_count > threatened_count) {
      # pick the first not threatened row
      which.max(Threat == "not_threatened")
    } else {
      # If there is a tie between threatened and not threatened rows,
      # break by severity groups.
      # Count severity categories
      threatened_severity_count <- sum(Redlist_cat %in% severity_threatened)
      not_threatened_severity_count <- sum(Redlist_cat %in% severity_not_threatened)
      # If threatened severity count ≥ not threatened severity count
      if (threatened_severity_count >= not_threatened_severity_count) {
        # Picks the first row with CR/EN/VU
        which.max(Redlist_cat %in% severity_threatened)
        # Else
      } else {
        # Picks the first row with NT/LC
        which.max(Redlist_cat %in% severity_not_threatened)
      }
    }
  }) %>%
  ungroup()
```

For Russia, check that there is only one entry for each species:

```{r}
redlist_phenobs_Russia %>% group_by(species) %>%
  count() %>% filter(n > 1)
```

Join noRussia and Russia to get final RL for PhenObs:

```{r}
redlist_phenobs_final <- bind_rows(redlist_phenobs_noRussia_latest,
                                   redlist_phenobs_Russia)
# Note that species that are not threatened in any country 
# are absent from redlist_phenobs_final
```

# Join occurrence data and Red List data 

```{r}
occurrence_matrix_species_countries %>% distinct(COUNTRY)
redlist_phenobs_final %>% distinct(Country_WGSRPD)
```

Remove Turkey from occurrence_matrix_species_countries:

```{r}
occurrence_matrix_species_countries <- occurrence_matrix_species_countries %>%
  filter(COUNTRY != "Turkey")
```

Resolve occurrence_matrix_species_countries$taxon_name to GBIF accepted names:

```{r}
occurrence_matrix_species_countries_matched <- resolve_vec(
  occurrence_matrix_species_countries$taxon_name) %>%
  mutate(source = "sp_list") %>%
  # Keep original species for reference
  bind_cols(occurrence_matrix_species_countries %>%
              rename(original_species = taxon_name))
# Inspect resolution quality
occurrence_matrix_species_countries_matched %>%
   count(match_type, match_status, matched_rank)
```

```{r}
occurrence_matrix_species_countries_matched <- 
  occurrence_matrix_species_countries_matched %>%
  # Use acceptedScientificName from GBIF as species name
  mutate(species = acceptedScientificName) %>%
  # Clean whitespace and keep only "Genus species"
  mutate(species = str_squish(species),
         species = case_when(
           is.na(species) ~ NA_character_,
           species == "Iris × germanica L." ~ "Iris × germanica", # Special case
           .default = word(species, 1, 2) # first two words
           ))
```

```{r}
redlist_phenobs_final_occ <- 
  # Here, all 169 present species are included
  occurrence_matrix_species_countries_matched %>%
  # Here, only the species included in red lists in ANY country are included
  left_join(redlist_phenobs_final, by = c("species" = "species",
                                          "COUNTRY" = "Country_WGSRPD")) %>%
  # Remove unneded columns
  select(-Redlist_cat, -Country, -Publ_year, -redlist_source, 
         - Continent) %>%
  # Rename
  rename(country = COUNTRY, threat = Threat) %>%
  # Order columns
  select(species, country, occurrence, threat) %>%
  # Set those where Threat is NA or not_evaluated_dd (only 2 spp in Russia)
  # as not_threatened
  mutate(threat = case_when(
    threat == "not_evaluated_dd" ~ "not_threatened",
    is.na(threat) ~ "not_threatened",
    TRUE ~ threat
  ))
```

# Calculate % endangerment

```{r}
perc_endangerment <- redlist_phenobs_final_occ %>%
  filter(occurrence > 0) %>%  # only countries where species is present
  group_by(species) %>%
  summarise(
    total_countries = n(),
    threatened_countries = sum(threat == "threatened"),
    perc_endangerment = (threatened_countries / total_countries) * 100,
    .groups = "drop"
  ) %>%
  arrange(species) %>%
  # Have it also as a proportion
  mutate(prop_endangerment = perc_endangerment / 100)
perc_endangerment
```

# Sensitivity data

Slopes from Robert.

## Flowering

```{r}
sensitivity_data_fl <- read_csv(here("data", "raw", "slopes_20251128", "Overview_Slopes_Flowering.csv")) %>%
  select(-...1) 
```

Resolve sensitivity_data_fl$Species to GBIF accepted names:

```{r}
sensitivity_data_fl_matched <- resolve_vec(sensitivity_data_fl$Species) %>%
  # Keep original species for reference
  bind_cols(sensitivity_data_fl %>% rename(original_species = Species))
# Inspect resolution quality
sensitivity_data_fl_matched %>%
   count(match_type, match_status, matched_rank)
```


```{r}
sensitivity_data_fl_matched <- sensitivity_data_fl_matched %>%
  # Rename columns
  rename(mean_slope_fl = mean_slope, ci_lower_fl = ci_lower,
         ci_upper_fl = ci_upper, slope_var_fl = slope_var) %>%
  # Add variable for "sens" vs "not-sens"
  mutate(sens_01_fl = factor(ifelse(ci_lower_fl > 0 | ci_upper_fl < 0, 1, 0))) %>%
  # Calculate absolute value of mean slope
  mutate(mean_slope_abs_fl = abs(mean_slope_fl)) %>%
  # Use acceptedScientificName from GBIF as species name
  mutate(species = acceptedScientificName) %>%
  # Clean whitespace and keep only "Genus species"
  mutate(species = str_squish(species),
         species = case_when(
           is.na(species) ~ NA_character_,
           species == "Iris × germanica L." ~ "Iris × germanica", # Special case
           .default = word(species, 1, 2) # first two words
           )) %>%
  # Remove unneeded columns
  select(-query_name, -matched_name, - matched_rank, - match_type, 
         -match_status,, -usageKey, -acceptedUsageKey, -kingdom, -phylum,
         -class, -order, -family, -genus, -original_species)
sensitivity_data_fl_matched
```

## GSL

```{r}
sensitivity_data_GSL <- read_csv(here("data", "raw", "slopes_20251128", "Overview_Slopes_GSL.csv")) %>%
  select(-...1)
```

Resolve sensitivity_data_fl$Species to GBIF accepted names:

```{r}
sensitivity_data_GSL_matched <- resolve_vec(sensitivity_data_GSL$Species) %>%
  # Keep original species for reference
  bind_cols(sensitivity_data_GSL %>% rename(original_species = Species))
# Inspect resolution quality
sensitivity_data_GSL_matched %>%
   count(match_type, match_status, matched_rank)
```

```{r}
sensitivity_data_GSL_matched <- sensitivity_data_GSL_matched %>%
  # Rename columns
  rename(mean_slope_GSL = mean_slope, ci_lower_GSL = ci_lower,
         ci_upper_GSL = ci_upper, slope_var_GSL = slope_var) %>%
  # Add variable for "sens" vs "not-sens"
  mutate(sens_01_GSL = factor(ifelse(ci_lower_GSL > 0 | ci_upper_GSL < 0, 1, 0))) %>%
  # Calculate absolute value of mean slope
  mutate(mean_slope_abs_GSL = abs(mean_slope_GSL)) %>%
  # Use acceptedScientificName from GBIF as species name
  mutate(species = acceptedScientificName) %>%
  # Clean whitespace and keep only "Genus species"
  mutate(species = str_squish(species),
         species = case_when(
           is.na(species) ~ NA_character_,
           species == "Iris × germanica L." ~ "Iris × germanica", # Special case
           .default = word(species, 1, 2) # first two words
           )) %>%
  # Remove unneeded columns
  select(-query_name, -matched_name, - matched_rank, - match_type, 
         -match_status,, -usageKey, -acceptedUsageKey, -kingdom, -phylum,
         -class, -order, -family, -genus, -original_species)
sensitivity_data_GSL_matched
```

# Prepare dataset for models

```{r}
sens_per_endanger <- perc_endangerment %>% 
  left_join(
    sensitivity_data_fl_matched %>% 
      select(species, mean_slope_fl, sens_01_fl, mean_slope_abs_fl, ci_lower_fl,
             ci_upper_fl, slope_var_fl) 
    ) %>% 
  left_join(
    sensitivity_data_GSL_matched %>% 
      select(species, mean_slope_GSL, sens_01_GSL, mean_slope_abs_GSL,
             ci_lower_GSL, ci_upper_GSL, slope_var_GSL)
    )
sens_per_endanger %>% filter(is.na(perc_endangerment))
sens_per_endanger %>% filter(is.na(mean_slope_fl))
sens_per_endanger %>% filter(is.na(mean_slope_GSL))
```

# Distributions

```{r}
ggplot(sens_per_endanger, aes(x = perc_endangerment)) +
  geom_histogram(color = "black", fill = "lightblue") +
  theme_bw() +
  xlab("% endangerment") + ylab("N species")

ggplot(sens_per_endanger, aes(x = mean_slope_fl)) +
  geom_histogram(color = "black", fill = "lightblue") +
  theme_bw() +
  xlab("Mean slope (flowering)") + ylab("N species")

ggplot(sens_per_endanger, aes(x = mean_slope_abs_fl)) +
  geom_histogram(color = "black", fill = "lightblue") +
  theme_bw() +
  xlab("Mean slope (absolute value) (flowering)") + ylab("N species")

ggplot(sens_per_endanger, aes(x = sens_01_fl)) +
  geom_histogram(color = "black", fill = "lightblue", stat = "count") +
  theme_bw() +
  xlab("Sensitivity (0/1) (flowering)") + ylab("N species")

ggplot(sens_per_endanger, aes(x = mean_slope_GSL)) +
  geom_histogram(color = "black", fill = "lightblue") +
  theme_bw() +
  xlab("Mean slope (GSL)") + ylab("N species")

ggplot(sens_per_endanger, aes(x = mean_slope_abs_GSL)) +
  geom_histogram(color = "black", fill = "lightblue") +
  theme_bw() +
  xlab("Mean slope (absolute value) (GSL)") + ylab("N species")

ggplot(sens_per_endanger, aes(x = sens_01_GSL)) +
  geom_histogram(color = "black", fill = "lightblue", stat = "count") +
  theme_bw() +
  xlab("Sensitivity (0/1) (GSL)") + ylab("N species")
```

# Models all Europe

## Filtering slope_var < 100

### Sensitive or not

```{r}
# perc_endangerment is in percentage, so use counts:
# successes = threatened_countries
# failures = total_countries - threatened_countries
model_threat_sens_01_fl_100 <- glmmTMB(
  cbind(threatened_countries, total_countries - threatened_countries) ~
    sens_01_fl, family = binomial, data = sens_per_endanger %>%
    filter(slope_var_fl < 100))
model_threat_sens_01_GSL_100 <- glmmTMB(
  cbind(threatened_countries, total_countries - threatened_countries) ~
    sens_01_GSL, family = binomial, data = sens_per_endanger %>%
    filter(slope_var_GSL < 100))
summary(model_threat_sens_01_fl_100)
summary(model_threat_sens_01_GSL_100)
```

#### Plot predictions

```{r}
ggplot() +
  geom_point(data = data.frame(ggpredict(model_threat_sens_01_fl_100)),
             aes(x = sens_01_fl.x, y = sens_01_fl.predicted), size = 3) +
  geom_errorbar(data = data.frame(ggpredict(model_threat_sens_01_fl_100)),
                aes(x = sens_01_fl.x, y = sens_01_fl.predicted, 
                    ymin = sens_01_fl.conf.low, ymax = sens_01_fl.conf.high),
                width = 0.25) +
  theme_bw() + ggtitle("p = 0.043") +
  xlab("Sensitivity (0/1) (flowering)") +
  ylab("Predicted probability of endangerment")
ggplot() +
  geom_point(data = data.frame(ggpredict(model_threat_sens_01_GSL_100)),
             aes(x = sens_01_GSL.x, y = sens_01_GSL.predicted), size = 3) +
  geom_errorbar(data = data.frame(ggpredict(model_threat_sens_01_GSL_100)),
                aes(x = sens_01_GSL.x, y = sens_01_GSL.predicted, 
                    ymin = sens_01_GSL.conf.low, ymax = sens_01_GSL.conf.high),
                width = 0.25) +
  theme_bw() + ggtitle("p = 0.075") +
  xlab("Sensitivity (0/1) (GSL)") +
  ylab("Predicted probability of endangerment")
```

### Mean slope flowering (absolute value - negative slopes)

```{r}
# Model without ZI
model_threat_mean_slope_neg_fl_100 <- glmmTMB(
  cbind(threatened_countries, total_countries - threatened_countries) ~
    mean_slope_abs_fl, family = binomial, 
  data = sens_per_endanger %>% filter(mean_slope_fl < 0 & slope_var_fl < 100))
# Model with ZI
model_threat_mean_slope_neg_fl_zi_100 <- glmmTMB(
  prop_endangerment ~ mean_slope_abs_fl, family = "beta_family", 
  ziformula=~.,
  data = sens_per_endanger %>% filter(mean_slope_fl < 0 & slope_var_fl < 100))
summary(model_threat_mean_slope_neg_fl_100)
summary(model_threat_mean_slope_neg_fl_zi_100)
```

#### Plot predictions

```{r}
# Model without ZI
ggplot() +
  geom_ribbon(data = data.frame(ggpredict(model_threat_mean_slope_neg_fl_100,
                                          terms="mean_slope_abs_fl [all]")),
            aes(x = x, y = predicted, ymin = conf.low, ymax = conf.high),
            alpha = 0.25, fill = "blue") +
  geom_line(data = data.frame(ggpredict(model_threat_mean_slope_neg_fl_100,
                                        terms="mean_slope_abs_fl [all]")),
            aes(x = x, y = predicted), color = "blue", linewidth = 1) +
  geom_point(data = sens_per_endanger %>%
               filter(mean_slope_fl < 0 & slope_var_fl < 100),
             aes(x = mean_slope_abs_fl, y = prop_endangerment), alpha = 0.6) +
  theme_bw() + ggtitle("p = 0.017") +
  xlab("Sensitivity (absolute value) (flowering)") +
  ylab("Predicted probability of endangerment")
# Model with ZI
grid.arrange(
  ggplot() +
    geom_ribbon(data = data.frame(ggpredict(model_threat_mean_slope_neg_fl_zi_100,
                                            type = "fixed",
                                            terms="mean_slope_abs_fl [all]")),
                aes(x = x, y = predicted, ymin = conf.low, ymax = conf.high),
                alpha = 0.25, fill = "blue") +
    geom_line(data = data.frame(ggpredict(model_threat_mean_slope_neg_fl_zi_100,
                                          type = "fixed",
                                          terms="mean_slope_abs_fl [all]")),
              aes(x = x, y = predicted), color = "blue", linewidth = 1) +
    geom_point(data = sens_per_endanger %>%
                 filter(mean_slope_fl < 0 & slope_var_fl < 100 &
                          prop_endangerment > 0),
               aes(x = mean_slope_abs_fl, y = prop_endangerment), alpha = 0.6) +
    theme_bw() + ggtitle("p = 0.005") +
    xlab("Sensitivity (absolute value) (flowering)") +
    ylab("Predicted probability of endangerment"),
  ggplot() +
    geom_ribbon(data = data.frame(ggpredict(model_threat_mean_slope_neg_fl_zi_100,
                                            type = "zi_prob",
                                            terms="mean_slope_abs_fl [all]")),
                aes(x = x, y = 1-predicted, ymin = 1-conf.low, 
                    ymax = 1-conf.high),
                alpha = 0.25, fill = "blue") +
    geom_line(data = data.frame(ggpredict(model_threat_mean_slope_neg_fl_zi_100,
                                          type = "zi_prob",
                                          terms="mean_slope_abs_fl [all]")),
              aes(x = x, y = 1-predicted), color = "blue", linewidth = 1) +
    geom_point(data = sens_per_endanger %>%
                 filter(mean_slope_fl < 0 & slope_var_fl < 100) %>%
                 mutate(endangerment_01 = ifelse(prop_endangerment == 0, 0, 1)),
               aes(x = mean_slope_abs_fl, y = endangerment_01), alpha = 0.6) +
    theme_bw() + ggtitle("p = 0.632") +
    xlab("Sensitivity (absolute value) (flowering)") +
    ylab("Predicted probability of being endangered"),
  ncol = 2)
```

### Mean slope GSL (quadratic model)

```{r}
# Model without ZI
model_threat_mean_slope_GSL_100 <- glmmTMB(
  cbind(threatened_countries, total_countries - threatened_countries) ~
    mean_slope_GSL + I(mean_slope_GSL^2), family = binomial, 
  data = sens_per_endanger %>% filter(slope_var_GSL < 100))
# Model with ZI
model_threat_mean_slope_GSL_zi_100 <- glmmTMB(
  prop_endangerment ~ mean_slope_GSL + I(mean_slope_GSL^2), 
  family = "beta_family", ziformula=~.,
  data = sens_per_endanger %>% filter(slope_var_GSL < 100))
summary(model_threat_mean_slope_GSL_100)
summary(model_threat_mean_slope_GSL_zi_100)
```

#### Plot predictions

```{r}
# Model without ZI
ggplot() +
  geom_ribbon(data = data.frame(ggpredict(model_threat_mean_slope_GSL_100,
                                          terms="mean_slope_GSL [all]")),
            aes(x = x, y = predicted, ymin = conf.low, ymax = conf.high),
            alpha = 0.25, fill = "blue") +
  geom_line(data = data.frame(ggpredict(model_threat_mean_slope_GSL_100,
                                        terms="mean_slope_GSL [all]")),
            aes(x = x, y = predicted), color = "blue", linewidth = 1) +
  geom_point(data = sens_per_endanger %>%
               filter(slope_var_GSL < 100),
             aes(x = mean_slope_GSL, y = prop_endangerment), alpha = 0.6) +
  theme_bw() + ggtitle("p = 0.033") +
  xlab("Sensitivity (GSL)") +
  ylab("Predicted probability of endangerment")
# Model with ZI
grid.arrange(
  ggplot() +
    geom_ribbon(data = data.frame(ggpredict(model_threat_mean_slope_GSL_zi_100,
                                            type = "fixed",
                                            terms="mean_slope_GSL [all]")),
                aes(x = x, y = predicted, ymin = conf.low, ymax = conf.high),
                alpha = 0.25, fill = "blue") +
    geom_line(data = data.frame(ggpredict(model_threat_mean_slope_GSL_zi_100,
                                          type = "fixed",
                                          terms="mean_slope_GSL [all]")),
              aes(x = x, y = predicted), color = "blue", linewidth = 1) +
    geom_point(data = sens_per_endanger %>%
                 filter(slope_var_GSL < 100 &
                          prop_endangerment > 0),
               aes(x = mean_slope_GSL, y = prop_endangerment), alpha = 0.6) +
    theme_bw() + ggtitle("p = 0.448") +
    xlab("Sensitivity (GSL)") +
    ylab("Predicted probability of endangerment"),
  ggplot() +
    geom_ribbon(data = data.frame(ggpredict(model_threat_mean_slope_GSL_zi_100,
                                            type = "zi_prob",
                                            terms="mean_slope_GSL [all]")),
                aes(x = x, y = 1-predicted, ymin = 1-conf.low, 
                    ymax = 1-conf.high),
                alpha = 0.25, fill = "blue") +
    geom_line(data = data.frame(ggpredict(model_threat_mean_slope_GSL_zi_100,
                                          type = "zi_prob",
                                          terms="mean_slope_GSL [all]")),
              aes(x = x, y = 1-predicted), color = "blue", linewidth = 1) +
    geom_point(data = sens_per_endanger %>%
                 filter(slope_var_GSL < 100) %>%
                 mutate(endangerment_01 = ifelse(prop_endangerment == 0, 0, 1)),
               aes(x = mean_slope_GSL, y = endangerment_01), alpha = 0.6) +
    theme_bw() + ggtitle("p = 0.148") +
    xlab("Sensitivity (GSL)") +
    ylab("Predicted probability of being endangered"),
  ncol = 2)
```

## Filtering slope_var < 50

### Sensitive or not

```{r}
# perc_endangerment is in percentage, so use counts:
# successes = threatened_countries
# failures = total_countries - threatened_countries
model_threat_sens_01_fl_50 <- glmmTMB(
  cbind(threatened_countries, total_countries - threatened_countries) ~
    sens_01_fl, family = binomial, data = sens_per_endanger %>%
    filter(slope_var_fl < 50))
model_threat_sens_01_GSL_50 <- glmmTMB(
  cbind(threatened_countries, total_countries - threatened_countries) ~
    sens_01_GSL, family = binomial, data = sens_per_endanger %>%
    filter(slope_var_GSL < 50))
summary(model_threat_sens_01_fl_50)
summary(model_threat_sens_01_GSL_50)
```

#### Plot predictions

```{r}
ggplot() +
  geom_point(data = data.frame(ggpredict(model_threat_sens_01_fl_50)),
             aes(x = sens_01_fl.x, y = sens_01_fl.predicted), size = 3) +
  geom_errorbar(data = data.frame(ggpredict(model_threat_sens_01_fl_50)),
                aes(x = sens_01_fl.x, y = sens_01_fl.predicted, 
                    ymin = sens_01_fl.conf.low, ymax = sens_01_fl.conf.high),
                width = 0.25) +
  theme_bw() + ggtitle("p = 0.098") +
  xlab("Sensitivity (0/1) (flowering)") +
  ylab("Predicted probability of endangerment")
ggplot() +
  geom_point(data = data.frame(ggpredict(model_threat_sens_01_GSL_50)),
             aes(x = sens_01_GSL.x, y = sens_01_GSL.predicted), size = 3) +
  geom_errorbar(data = data.frame(ggpredict(model_threat_sens_01_GSL_50)),
                aes(x = sens_01_GSL.x, y = sens_01_GSL.predicted, 
                    ymin = sens_01_GSL.conf.low, ymax = sens_01_GSL.conf.high),
                width = 0.25) +
  theme_bw() + ggtitle("p = 0.384") +
  xlab("Sensitivity (0/1) (GSL)") +
  ylab("Predicted probability of endangerment")
```

### Mean slope flowering (absolute value - negative slopes)

```{r}
# Model without ZI
model_threat_mean_slope_neg_fl_50 <- glmmTMB(
  cbind(threatened_countries, total_countries - threatened_countries) ~
    mean_slope_abs_fl, family = binomial, 
  data = sens_per_endanger %>% filter(mean_slope_fl < 0 & slope_var_fl < 50))
# Model with ZI
model_threat_mean_slope_neg_fl_zi_50 <- glmmTMB(
  prop_endangerment ~ mean_slope_abs_fl, family = "beta_family", 
  ziformula=~.,
  data = sens_per_endanger %>% filter(mean_slope_fl < 0 & slope_var_fl < 50))
summary(model_threat_mean_slope_neg_fl_50)
summary(model_threat_mean_slope_neg_fl_zi_50)
```

#### Plot predictions

```{r}
# Model without ZI
ggplot() +
  geom_ribbon(data = data.frame(ggpredict(model_threat_mean_slope_neg_fl_50,
                                          terms="mean_slope_abs_fl [all]")),
            aes(x = x, y = predicted, ymin = conf.low, ymax = conf.high),
            alpha = 0.25, fill = "blue") +
  geom_line(data = data.frame(ggpredict(model_threat_mean_slope_neg_fl_50,
                                        terms="mean_slope_abs_fl [all]")),
            aes(x = x, y = predicted), color = "blue", linewidth = 1) +
  geom_point(data = sens_per_endanger %>%
               filter(mean_slope_fl < 0 & slope_var_fl < 50),
             aes(x = mean_slope_abs_fl, y = prop_endangerment), alpha = 0.6) +
  theme_bw() + ggtitle("p = 0.022") +
  xlab("Sensitivity (absolute value) (flowering)") +
  ylab("Predicted probability of endangerment")
# Model with ZI
grid.arrange(
  ggplot() +
    geom_ribbon(data = data.frame(ggpredict(model_threat_mean_slope_neg_fl_zi_50,
                                            type = "fixed",
                                            terms="mean_slope_abs_fl [all]")),
                aes(x = x, y = predicted, ymin = conf.low, ymax = conf.high),
                alpha = 0.25, fill = "blue") +
    geom_line(data = data.frame(ggpredict(model_threat_mean_slope_neg_fl_zi_50,
                                          type = "fixed",
                                          terms="mean_slope_abs_fl [all]")),
              aes(x = x, y = predicted), color = "blue", linewidth = 1) +
    geom_point(data = sens_per_endanger %>%
                 filter(mean_slope_fl < 0 & slope_var_fl < 50 &
                          prop_endangerment > 0),
               aes(x = mean_slope_abs_fl, y = prop_endangerment), alpha = 0.6) +
    theme_bw() + ggtitle("p = 0.005") +
    xlab("Sensitivity (absolute value) (flowering)") +
    ylab("Predicted probability of endangerment"),
  ggplot() +
    geom_ribbon(data = data.frame(ggpredict(model_threat_mean_slope_neg_fl_zi_50,
                                            type = "zi_prob",
                                            terms="mean_slope_abs_fl [all]")),
                aes(x = x, y = 1-predicted, ymin = 1-conf.low, 
                    ymax = 1-conf.high),
                alpha = 0.25, fill = "blue") +
    geom_line(data = data.frame(ggpredict(model_threat_mean_slope_neg_fl_zi_50,
                                          type = "zi_prob",
                                          terms="mean_slope_abs_fl [all]")),
              aes(x = x, y = 1-predicted), color = "blue", linewidth = 1) +
    geom_point(data = sens_per_endanger %>%
                 filter(mean_slope_fl < 0 & slope_var_fl < 50) %>%
                 mutate(endangerment_01 = ifelse(prop_endangerment == 0, 0, 1)),
               aes(x = mean_slope_abs_fl, y = endangerment_01), alpha = 0.6) +
    theme_bw() + ggtitle("p = 0.682") +
    xlab("Sensitivity (absolute value) (flowering)") +
    ylab("Predicted probability of being endangered"),
  ncol = 2)
```

### Mean slope GSL (quadratic model)

```{r}
# Model without ZI
model_threat_mean_slope_GSL_50 <- glmmTMB(
  cbind(threatened_countries, total_countries - threatened_countries) ~
    mean_slope_GSL + I(mean_slope_GSL^2), family = binomial, 
  data = sens_per_endanger %>% filter(slope_var_GSL < 50))
# Model with ZI
model_threat_mean_slope_GSL_zi_50 <- glmmTMB(
  prop_endangerment ~ mean_slope_GSL + I(mean_slope_GSL^2), 
  family = "beta_family", ziformula=~.,
  data = sens_per_endanger %>% filter(slope_var_GSL < 50))
summary(model_threat_mean_slope_GSL_50)
summary(model_threat_mean_slope_GSL_zi_50)
```

#### Plot predictions

```{r}
# Model without ZI
ggplot() +
  geom_ribbon(data = data.frame(ggpredict(model_threat_mean_slope_GSL_50,
                                          terms="mean_slope_GSL [all]")),
            aes(x = x, y = predicted, ymin = conf.low, ymax = conf.high),
            alpha = 0.25, fill = "blue") +
  geom_line(data = data.frame(ggpredict(model_threat_mean_slope_GSL_50,
                                        terms="mean_slope_GSL [all]")),
            aes(x = x, y = predicted), color = "blue", linewidth = 1) +
  geom_point(data = sens_per_endanger %>%
               filter(slope_var_GSL < 50),
             aes(x = mean_slope_GSL, y = prop_endangerment), alpha = 0.6) +
  theme_bw() + ggtitle("p = 0.002") +
  xlab("Sensitivity (GSL)") +
  ylab("Predicted probability of endangerment")
# Model with ZI
grid.arrange(
  ggplot() +
    geom_ribbon(data = data.frame(ggpredict(model_threat_mean_slope_GSL_zi_50,
                                            type = "fixed",
                                            terms="mean_slope_GSL [all]")),
                aes(x = x, y = predicted, ymin = conf.low, ymax = conf.high),
                alpha = 0.25, fill = "blue") +
    geom_line(data = data.frame(ggpredict(model_threat_mean_slope_GSL_zi_50,
                                          type = "fixed",
                                          terms="mean_slope_GSL [all]")),
              aes(x = x, y = predicted), color = "blue", linewidth = 1) +
    geom_point(data = sens_per_endanger %>%
                 filter(slope_var_GSL < 50 &
                          prop_endangerment > 0),
               aes(x = mean_slope_GSL, y = prop_endangerment), alpha = 0.6) +
    theme_bw() + ggtitle("p = 0.296") +
    xlab("Sensitivity (GSL)") +
    ylab("Predicted probability of endangerment"),
  ggplot() +
    geom_ribbon(data = data.frame(ggpredict(model_threat_mean_slope_GSL_zi_50,
                                            type = "zi_prob",
                                            terms="mean_slope_GSL [all]")),
                aes(x = x, y = 1-predicted, ymin = 1-conf.low, 
                    ymax = 1-conf.high),
                alpha = 0.25, fill = "blue") +
    geom_line(data = data.frame(ggpredict(model_threat_mean_slope_GSL_zi_50,
                                          type = "zi_prob",
                                          terms="mean_slope_GSL [all]")),
              aes(x = x, y = 1-predicted), color = "blue", linewidth = 1) +
    geom_point(data = sens_per_endanger %>%
                 filter(slope_var_GSL < 50) %>%
                 mutate(endangerment_01 = ifelse(prop_endangerment == 0, 0, 1)),
               aes(x = mean_slope_GSL, y = endangerment_01), alpha = 0.6) +
    theme_bw() + ggtitle("p = 0.030") +
    xlab("Sensitivity (GSL)") +
    ylab("Predicted probability of being endangered"),
  ncol = 2)
```

# RL for Germany

```{r}
redlist_Germany <- redlist_phenobs %>% filter(Country == "Germany") %>%
  # Keep threat info for the latest publication year for each sp
  group_by(species) %>%
  filter(if (all(is.na(Publ_year))) TRUE else 
    Publ_year == max(Publ_year, na.rm = TRUE)) %>%
  # Only one case of two records of the same spp (Genista tinctoria)
  # for the same year, but everything in the row was duplicated
  slice(which.min(match(Redlist_cat, severity_order))) %>%
  ungroup()
```

Does not make sense to look at RL categories, cause there are 25 EN + 1 VU = 26 threatened, and 80 LC = 80 not threatened.

# Join occurrence data and RL for Germany

```{r}
redlist_Germany_occ <- 
  # Here, all 169 present species are included
  occurrence_matrix_species_countries_matched %>% filter(COUNTRY == "Germany") %>%
  # Here, only the species included in RL in Germany are included
  left_join(redlist_Germany, by = c("species" = "species",
                                          "COUNTRY" = "Country_WGSRPD")) %>%
  # Remove unneded columns
  select(-Redlist_cat, -Country, -Publ_year, -redlist_source, 
         - Continent) %>%
  # Rename
  rename(country = COUNTRY, threat = Threat) %>%
  # Order columns
  select(species, country, occurrence, threat) %>%
  # Set those where Threat is NA or not_evaluated_dd (only 2 spp in Russia)
  # as not_threatened
  mutate(threat = case_when(
    threat == "not_evaluated_dd" ~ "not_threatened",
    is.na(threat) ~ "not_threatened",
    TRUE ~ threat
  ))
```

```{r}
RL_threat_Germany <- redlist_Germany_occ %>%
  filter(occurrence > 0) %>% 
  select(species, threat)
```

# Prepare dataset for models

```{r}
sens_threat_Germany <- RL_threat_Germany %>% 
  mutate(threat = ifelse(threat == "threatened", 1, 0)) %>%
  left_join(
    sensitivity_data_fl_matched %>% 
      select(species, mean_slope_fl, sens_01_fl, mean_slope_abs_fl, ci_lower_fl,
             ci_upper_fl, slope_var_fl) 
    ) %>%
  left_join(
    sensitivity_data_GSL_matched %>% 
      select(species, mean_slope_GSL, sens_01_GSL, mean_slope_abs_GSL, 
             ci_lower_GSL, ci_upper_GSL, slope_var_GSL) 
    )
sens_threat_Germany %>% filter(is.na(threat))
sens_threat_Germany %>% filter(is.na(mean_slope_fl))
sens_threat_Germany %>% filter(is.na(mean_slope_GSL))
```

# Models for Germany

## Filtering slope_var < 100

### Sensitive or not

```{r}
# perc_endangerment is in percentage, so use counts:
# successes = threatened_countries
# failures = total_countries - threatened_countries
model_threat_sens_01_fl_100_G <- glmmTMB(
  threat ~ sens_01_fl, family = binomial, 
  data = sens_threat_Germany %>% filter(slope_var_fl < 100))
model_threat_sens_01_GSL_100_G <- glmmTMB(
  threat ~ sens_01_GSL, family = binomial, 
  data = sens_threat_Germany %>% filter(slope_var_GSL < 100))
summary(model_threat_sens_01_fl_100_G)
summary(model_threat_sens_01_GSL_100_G)
```

### Mean slope flowering (absolute value - negative slopes)

```{r}
model_threat_mean_slope_neg_fl_100_G <- glmmTMB(
  threat ~ mean_slope_abs_fl,
  family = binomial, 
  data = sens_threat_Germany %>% filter(mean_slope_fl < 0 & slope_var_fl < 100))
summary(model_threat_mean_slope_neg_fl_100_G)
```

### Mean slope GSL (quadratic model)

```{r}
model_threat_mean_slope_GSL_100_G <- glmmTMB(
  threat ~ mean_slope_GSL + I(mean_slope_GSL^2), family = binomial, 
  data = sens_threat_Germany %>% filter(slope_var_GSL < 100))
summary(model_threat_mean_slope_GSL_100_G)
```

## Filtering slope_var < 50

### Sensitive or not

```{r}
# perc_endangerment is in percentage, so use counts:
# successes = threatened_countries
# failures = total_countries - threatened_countries
model_threat_sens_01_fl_50_G <- glmmTMB(
  threat ~ sens_01_fl, family = binomial, 
  data = sens_threat_Germany %>% filter(slope_var_fl < 50))
model_threat_sens_01_GSL_50_G <- glmmTMB(
  threat ~ sens_01_GSL, family = binomial, 
  data = sens_threat_Germany %>% filter(slope_var_GSL < 50))
summary(model_threat_sens_01_fl_50_G)
summary(model_threat_sens_01_GSL_50_G)
```

### Mean slope flowering (absolute value - negative slopes)

```{r}
model_threat_mean_slope_neg_fl_50_G <- glmmTMB(
  threat ~ mean_slope_abs_fl,
  family = binomial, 
  data = sens_threat_Germany %>% filter(mean_slope_fl < 0 & slope_var_fl < 50))
summary(model_threat_mean_slope_neg_fl_50_G)
```

### Mean slope GSL (quadratic model)

```{r}
model_threat_mean_slope_GSL_50_G <- glmmTMB(
  threat ~ mean_slope_GSL + I(mean_slope_GSL^2), family = binomial, 
  data = sens_threat_Germany %>% filter(slope_var_GSL < 50))
summary(model_threat_mean_slope_GSL_50_G)
```

# Correlation mean slope flowering - GSL

```{r}
cor(sens_per_endanger$mean_slope_fl, sens_per_endanger$mean_slope_GSL,
    use = "complete.obs")
cor(sens_per_endanger$mean_slope_abs_fl, sens_per_endanger$mean_slope_abs_GSL,
    use = "complete.obs")
```

```{r}
ggplot(sens_per_endanger, aes(x = mean_slope_fl, y = mean_slope_GSL)) +
  geom_point() + geom_smooth()
ggplot(sens_per_endanger, aes(x = mean_slope_abs_fl, y = mean_slope_abs_GSL)) +
  geom_point() + geom_smooth()
```

# Stress tolerance

```{r}
stress <- read_delim(here("data", "raw", "Stress_Tolerance.csv"), delim = ";") %>%
  rename(stress_tol = `Stress tolerator score_percentage`)
stress
```

Resolve stress$species to GBIF accepted names:

```{r}
stress_matched <- resolve_vec(stress$Species) %>%
  # Keep original species for reference
  bind_cols(stress %>% rename(original_species = Species))
# Inspect resolution quality
stress_matched %>%
   count(match_type, match_status, matched_rank)
```

Join with sens_per_endanger:

```{r}
sens_per_endanger_stress <- sens_per_endanger %>%
  left_join(stress_matched %>%
              # Use acceptedScientificName from GBIF as species name 
              mutate(species = acceptedScientificName) %>%
              # Clean whitespace and keep only "Genus species"
              mutate(species = str_squish(species),
                     species = case_when(
                       is.na(species) ~ NA_character_,
                       species == "Iris × germanica L." ~ "Iris × germanica", # Special case
                       .default = word(species, 1, 2) # first two words
                       )) %>%
              select(species, stress_tol))
  
  stress_matched %>%
  select(query_name, matched_name, usageKey, acceptedUsageKey, 
         acceptedScientificName, source, original_species) %>%
  # Build canonical GBIF key
  mutate(gbif_key = coalesce(acceptedUsageKey, usageKey)) %>%
  select(-usageKey, -acceptedUsageKey, -matched_name, -acceptedScientificName,
         -source, -original_species) %>%
  left_join(
    redlist_matched_final %>%
      # Build canonical GBIF key
      mutate(gbif_key = coalesce(acceptedUsageKey, usageKey)) %>%
      select(-usageKey, -acceptedUsageKey),
    by = "gbif_key")
```

```{r}
redlist_phenobs_all <- redlist_phenobs_all %>%
  # Use acceptedScientificName from GBIF as species name 
  mutate(species = acceptedScientificName) %>%
  # Clean whitespace and keep only "Genus species"
  mutate(species = str_squish(species),
         species = case_when(
           is.na(species) ~ NA_character_,
           species == "Iris × germanica L." ~ "Iris × germanica", # Special case
           .default = word(species, 1, 2) # first two words
           )) %>%
  # Keep columns that I think I will use
  select(species, Redlist_cat, Threat, Country, Publ_year,
         redlist_source, Continent)
redlist_phenobs_all
```


# Session info

```{r}
sessionInfo()
```


